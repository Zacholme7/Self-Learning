// future type has state for each possible step it can pause
// - start, every await, when it finished
// when you write async function, compiler transforms it into 
// state machine where the state is often self referential

async fn foo<'a>(z: &'a mut i32) { ... }

async fn bar(x: i32, y: i32) -> i32 {
    let mut z = x + y;
    foo(&mut z).await;
    z
}

// could transform into this
enum Bar {
    // When it starts, it contains only its arguments
    Start { x: i32, y: i32 },
    // At the first await, it must contain `z` and the `Foo` future
    // that references `z`
    FirstAwait { z: i32, foo: Foo<'?> }
    // When its finished it needs no data
    Complete,
}

// if bar in first await state, then moves, then we have dangling pointers
// need to restrict it from moving, or pin it



// there may be cases where needs self referential data which is in 
// the internal state. this is why future types are self referential

// goal of Pin is to make it safe to manipulate self referential types 
// generated by compiler from async func or impl with unsafe code




fn main() {
    println!("Hello, world!");
}
